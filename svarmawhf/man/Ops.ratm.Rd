% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zz_ratmat_arithmetic_methods.R
\name{Ops.ratm}
\alias{Ops.ratm}
\title{Arithmetic Ops Group Methods for Rational Matrices}
\usage{
\method{Ops}{ratm}(e1, e2)
}
\arguments{
\item{e1, e2}{At least one of \code{e1, e2} must be an object of 
class \code{\link{polm}}, \code{\link{lmfd}}, \code{\link{rmfd}}, \code{\link{stsp}},
\code{\link{pseries}} or \code{\link{zvalues}}.}
}
\value{
Rational matrix object.
}
\description{
This function was originally part of the R-package \strong{rationalmatrices}.
\cr
Implements the following basic arithmetic operations on rational matrices
\itemize{
\item unitary operators \code{'+a'} and \code{'-a'}. 
\item the power (\code{'a^k'}) operator for \emph{square, non empty} rational matrices 
      \code{a} and integer powers \code{k}.   
\item elementwise multiplication (\code{'a * b'}) 
\item addition and substraction (\code{'a + b'} and \code{'a - b'})
\item elementwise polynomal division (\code{'a \%/\% b'}),
\item elementwise polynomial remainder (\code{'a \%\% b'}),
}
}
\details{
The unitary operators \code{'+a'} and \code{'-a'} are implemented for all classes. 

The power (\code{'a^k'}) operator is only implemented \emph{square}, rational matrices and integer powers \code{k}.
\itemize{
\item{\code{a^0} returns the identity matrix (represented by an object of the same class as the input argument \code{a}).} 
\item{\code{a^1} simply returns the input arguments \code{a}.} 
\item{The case \eqn{k>1} is implemented for all classes. 
    However, \code{lmfd} and \code{rmfd} objects are first coerced to \code{stsp} objects.} 
\item{The case \eqn{k<0} is implemented for all classes. 
    However, the matrix must be non empty and \code{polm} objects and \code{lmfd} and \code{rmfd} objects are first coerced to \code{stsp} objects.}
}
       
For the binary operators `a + b`, `a - b` and `a * b` the two arguments are 
first coerced to a common class according to the following scheme 
\tabular{rcll}{
matrix \tab -> \tab polm \tab (coerce non rational matrices to \code{polm} objects)\cr
lmfd   \tab -> \tab stsp \tab (coerce \code{lmfd} objects to \code{stsp} objects)\cr
rmfd   \tab -> \tab stsp \tab (coerce \code{rmfd} objects to \code{stsp} objects)\cr
polm o stsp  \tab -> \tab stsp \tab \cr
polm o pseries  \tab -> \tab pseries \tab \cr
polm o zvalues  \tab -> \tab zvalues \tab \cr
stsp o pseries  \tab -> \tab pseries \tab \cr
stsp o zvalues  \tab -> \tab zvalues \tab \cr
}

Note that \code{pseries} objects cannot be (easily) coerced to 
\code{zvalues} objects, so these binary operations throw an error, if 
one tries to combine an \code{pseries} with a \code{zvalues} object.

If two \code{pseries} objects are combined then they are truncated to the 
minimum of the respective number of “lags”. Two \code{zvalues} objects are 
only combined if the “z” values are identical. Otherwise an error is thrown.

Of course the two arguments have to be of compatible dimension. 
If one of the arguments is a scalar (\eqn{(1,1)} matrix) then this 
argument is "expanded" to a compatible matrix with identtical entries. 

Note that the computed statespace realizations are often non minimal! 
(This remark also applies for other operations on statespace realizations.)

For the matrix multiplication, see \code{\link{\%r\%}}.

The elementwise polynomal division (\code{'a \%/\% b'}) and the 
elementwise polynomial remainder (\code{'a \%\% b'}) are of course only implemented 
for polynomial matrices (\code{polm} objects) or (objects which may be coerced to 
\code{polm} objects). 

The above remark on scalar arguments also applies for these operations.
}
\examples{
# Multiplication (and division) of a scalar (from left and right)
a = test_polm(dim = c(2,2), degree = 3)
a
-a
a * (-1)
a \%/\% 0.5

# Addition
2 + a        # 2 is coerced to a constant matrix polynomial

# Elementwise remainder
a \%\% 0.5
0.5 \%\% a

# Elementwise division and multiplication with scalar polm
z = polm(c(0,1))
a \%/\% z
z * a
a * z^2

# (Non-negative integer) power of univariate polynomial 
# (useful for generating a polynomial matrix)
z^3
matrix(0, nrow = 2) + z * matrix(1, nrow = 2) + z^2 * matrix(2, nrow = 2)

# (Non-negative integer) power of quadratic polynomial matrices
a^0
a^1
a^2

}
