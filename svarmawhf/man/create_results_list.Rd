% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ab_create_results.R
\name{create_results_list}
\alias{create_results_list}
\title{Create results}
\usage{
create_results_list(theta_init, tmpl, params, DATASET)
}
\arguments{
\item{theta_init}{vector of doubles. Initial deep parameters. Obtained from \link{get_init_armamod_whf_random}.}

\item{tmpl}{SVARMA-WHF template. Obtained from \link{tmpl_whf_rev}.}

\item{params}{List. Contains optimisation parameters, some of which are taken from the SLURM script which calls this function. 
 The SLURM slots are
 \itemize{
   \item \code{USE_PARALLEL}: Actually set in the main script. Set to FALSE because we use array/jobs \url{https://scicomp.aalto.fi/triton/tut/array/} such that each job only uses one core. This is the most efficient way for embarrassingly parallel problems.
   \item \code{N_CORES}: Only relevant if slot \code{USE_PARALLEL} is set to TRUE. In that case, it is retrieved from the SLURM system environment.
   \item \code{N_MODS_PER_CORE}: Important parameter. Specifies how many models are estimated by each array-job. 
     Given as first parameter \code{$N_MODS_PER_CORE} in SLURM script \code{scriptsP_whf_revision_sgt_bq/b_slurm}.
   \item \code{IX_ARRAY_JOB}: Index of array-job. Number of array-jobs is determined from number of rows of dataframe containing all integer-values parameters
     Given as second parameter \code{$SLURM_ARRAY_TASK_ID} in SLURM script \code{scriptsP_whf_revision_sgt_bq/b_slurm}.
   \item \code{SLURM_JOB_ID}: Internal ID.
     Given as third parameter \code{$SLURM_JOB_ID} in SLURM script \code{scriptsP_whf_revision_sgt_bq/b_slurm}.
   \item \code{MANUALLY_ASSIGNED_ID}: Manually assigned job ID (same for each array job). Used to keep track of different runs.
     Given as fourth parameter \code{$MANUALLY_ASSIGNED_ID} in SLURM script \code{scriptsP_whf_revision_sgt_bq/b_slurm}.
 }
 The \emph{filename} slots are
 \itemize{
   \item \code{FILE_NAME_INPUT}: Path to rds file containing the data set. 
     Working directory is the location of the main script \code{scriptsP_whf_revision_sgt_bq/aa_Rscript4slurm_bq.R} called by \code{scriptsP_whf_revision_sgt_bq/b_slurm}.
     It is set to \code{"../local_data/g_gmr_bq/data_xts.rds"} in \code{scriptsP_whf_revision_sgt_bq/aa_Rscript4slurm_bq.R}.
   \item \code{PATH_RESULTS_HELPER}: Helper for creating the filenames of the outputs (rds files for each array job). 
     Filenames will eventually involve \code{MANUALLY_ASSIGNED_ID} and \code{IX_ARRAY_JOB}.
     Set to \code{"../local_data/p_whf/ukko_bq_"} in \code{scriptsP_whf_revision_sgt_bq/aa_Rscript4slurm_bq.R}.
 }
 The slots for maximal AR and MA orders (for each combination of (p,q) all partial indices are obtained) are:
 \itemize{
   \item \code{AR_ORDER_MAX}
   \item \code{MA_ORDER_MAX}
 }
 Next, there are some slots regarding optimisation. 
 It is advantageous to restart optimisation rather than increase the number of maximal iterations in \link[stats]{optim}.
 Also, using different methods (Nelder-Mead vs BFGS) has advantages over just using one method.
 For each restart, we perform first a BFGS optimisation, followed by Nelder-Mead.
 Only if the value of the likelihood function improves the corresponding optimizing argument is used in the subsequent optimisation.
 In order to investigate the convergence behaviour we perform these steps for different shock densities (Gaussian, Laplace, SGT).
 \itemize{
   \item \code{IT_OPTIM_GAUSS}: Number of restarts for Gaussian density. Set to 3.
   \item \code{USE_BFGS_GAUSS}: boolean; whether BFGS method should be used in \link[stats]{optim}. Set to \code{TRUE}.
   \item \code{USE_NM_GAUSS}: boolean; whether BFGS method should be used in \link[stats]{optim}. Set to \code{TRUE}.
   \item \code{MAXIT_BFGS_GAUSS}: integer. Number of maximal iterations in BFGS method. Set to 80. Default is 100 in \link[stats]{optim}.
   \item \code{MAXIT_NM_GAUSS}: integer. Number of maximal iterations in Nelder-Mead method. Set to 1000. Default is 500 in \link[stats]{optim}.
   \item \code{IT_OPTIM_LAPLACE}: Same as above but for Laplace density. Set to 3.
   \item \code{USE_BFGS_LAPLACE}: Same as above but for Laplace density. Set to \code{TRUE}.
   \item \code{USE_NM_LAPLACE}: Same as above but for Laplace density. Set to \code{TRUE}.
   \item \code{MAXIT_BFGS_LAPLACE}: Same as above but for Laplace density. Set to 100. 
   \item \code{MAXIT_NM_LAPLACE}: Same as above but for Laplace density. Set to 2000.
   \item \code{IT_OPTIM_SGT}: Same as above but for SGT densities. Set to 4.
   \item \code{USE_BFGS_SGT}: Same as above but for SGT densities. Set to \code{TRUE}.
   \item \code{USE_NM_SGT}: Same as above but for SGT densities. Set to \code{TRUE}.
   \item \code{MAXIT_BFGS_SGT}: Same as above but for SGT densities. Set to 100.
   \item \code{MAXIT_NM_SGT}: Same as above but for SGT densities. Set to 3000.
}}

\item{DATASET}{matrix. data where each column corresponds to a variable and each row to an observation.}
}
\value{
List with slots \code{params_deep_final}, containing the optimizing deep parameter for the SGT density, \code{value_final}, value of the optimisation function, \code{results_list}, list containing detailed output.
The slot \code{results_list} has, in turn, the following slots:
\itemize{
\item \code{scriptparams}: equal to input argument \code{params}.
\item \code{input_integerparams}: (p,q, kappa, k)
\item \code{initial}: List with slots \code{theta} (for deep parameters) and \code{value_laplace} (value of laplace density for the initial deep parameters, which is tracked throughout all optimisations including the ones for the other densities).
\item \code{gaussian}: List which contains all results for the Gaussian density optimisation.
  Number of (unnamed) slots is equal to \code{params$IT_OPTIM_GAUSS}. 
  Each of these slots contains a list with slots \code{BFGS} and \code{NM} which are in turn lists that store the output of \link[stats]{optim}. 
  The slots for each optimisation method contain the following named slots:
  \itemize{
    \item \code{convergence}: Integer describing the convergence behaviour of the optimisation in \link[stats]{optim}. 
      0 means convergence, 1 means number of maximal iterations reached before convergence (this happens more often for Nelder-Mead than for BFGS), 
      2 is a code defined by myself and indicates whether \link[stats]{optim} threw an error, 10 stands for a degenerate NM simplex.
    \item \code{duration}: saves the runtime of the optimisation
    \item \code{msg}: Error message or success message
    \item \code{theta}: deep parameters
    \item \code{value}: value of likelihood function of the current kind
    \item \code{value_laplace}: value of Laplace likelihood which is tracked throughout all optimisations
  }
\item \code{ic} list with slots \code{theta} (after rotating the noise parameters using \link[steadyICA]{steadyICA}), and \code{value_laplace}. 
\item \code{laplace} and \code{sgt}: Same as slot \code{gaussian} but for Laplace density and SGT densities
}
}
\description{
Called by main script \code{scriptsP_whf_revision_sgt_bq/aa_Rscript4slurm_bq.R}.
Calls \link{ll_whf_factory}, \link{get_ic}, \link{replace_noise}.
\cr
This function is called in a parallelized fashion by the main script \code{scriptsP_whf_revision_sgt_bq/aa_Rscript4slurm_bq.R} (which in turn is called by the SLURM batch job, see file \code{scriptsP_whf_revision_sgt_bq/b_slurm}.
\cr
For given initial values and a template, it creates all (optimisation) output which is needed for further analysis, see the return value below.
}
