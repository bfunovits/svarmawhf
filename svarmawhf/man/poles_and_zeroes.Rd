% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zz_ratmat_poles_and_zeroes.R,
%   R/zz_rldm_poles_and_zeroes.R
\name{poles and zeroes}
\alias{poles and zeroes}
\alias{poles}
\alias{zeroes}
\alias{zeroes.polm}
\alias{poles.polm}
\alias{zeroes.lmfd}
\alias{poles.lmfd}
\alias{zeroes.armamod}
\alias{poles.armamod}
\alias{zeroes.rmfdmod}
\alias{poles.rmfdmod}
\alias{zeroes.stspmod}
\alias{poles.stspmod}
\title{Poles and Zeroes}
\usage{
poles(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

zeroes(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{zeroes}{polm}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{poles}{polm}(x, ...)

\method{zeroes}{lmfd}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{poles}{lmfd}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{zeroes}{armamod}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{poles}{armamod}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{zeroes}{rmfdmod}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{poles}{rmfdmod}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{zeroes}{stspmod}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)

\method{poles}{stspmod}(x, tol = sqrt(.Machine$double.eps), print_message = TRUE, ...)
}
\arguments{
\item{x}{an object which represents a VARMA, RMFD or statespace model
(i.e. an \code{\link{armamod}}, \code{\link{rmfdmod}} or \code{\link{stspmod}} object).}

\item{tol}{Double. Default set to \code{sqrt(.Machine$double.eps)}.
Required to decide on when a root is to be considered "at infinity".}

\item{print_message}{Boolean. Default set to TRUE.
Prints a message if roots "at infinity " are discarded.}

\item{...}{not used.}
}
\value{
Vector of poles, respectively zeroes.

Vector of poles, respectively zeroes.
}
\description{
This function was originally part of the R-package \strong{rationalmatrices}.
\cr
Compute the poles and zeroes of a rational matrix. For polynomial matrices and rational matrices 
in left matrix fraction form the poles (and zeroes) are computed via the (reciprocals of the) 
eigenvalues of the associated companion matrices, see also \code{\link{companion_matrix}}. 
For statespace realizations the poles are computed via (the reciprocals of) the 
eigenvalues of the state transition matrix \eqn{A} and for the zeroes 
the eigenvalues of the state transition matrix \eqn{A-BD^{-1}C} of the inverse are used.

This function was originally part of the R-package \strong{RLDM}.
\cr
Compute the poles and zeroes of VARMA and Statespace models. Note that these models describe 
the corresponding processes as 
\deqn{x_t = k(B) u_t}{x[t] = k(B) + u[t]}
where \eqn{(u_t)}{(u[t])} is a white noise process and \eqn{k(B)} is a rational filter 
(\eqn{B} denotes the lag- or backward shift operator). 
The poles and zeroes are the poles and zeroes of the rational transfer function 
\eqn{k(z)} of this filter.
}
\details{
The methods do not return numerically reliable and correct results in all cases. 
For some more details see the vignette \href{../doc/rational_matrices.html}{Rational Matrices}. 

\itemize{
\item Zeroes are only computed for square, non singular matrices which have no zero 
      at \eqn{z=0}. If the matrix evaluated at \eqn{z=0} is close to singular, 
      the results may be unreliable. 
\item The procedures use a threshold \code{tol} in order to decide whether 
      a small eigenvalue returned by \code{\link{eigen}} corresponds to 
      a "true zero" eigenvalue or not. 
\item If the pair \eqn{a,b} of polynomials of the LMFD is not left coprime then 
      a pole/zero cancellation occurs. This is not taken into account by the procedures. Hence, 
      in this case, the results also contain some spurious poles/zeroes. This happens 
      also for non minimal state space realizations.      
}
}
\examples{
 
# zeroes of polynomial matrices #############################################

# scalar polynomial ###
a = polm(c(1, 0, 0, 0.5, 0))
(z = zeroes(a))

# compare with the result of "polyroot"
all.equal(sort(z), sort(polyroot(as.vector(a))))

# zero degree polynomial (have no zeroes) ###
zeroes(polm(diag(3)))

# (2 x 2) polynomial of degree 2 ### 
a = polm(dbind(d = 3, diag(2), test_array(dim = c(2,2,2))))
(z = zeroes(a))

\dontrun{
# the following examples throw an error
zeroes(polm(c(0, 0, 0, 0.5))) # constant term is zero
zeroes(polm(test_array(dim = c(2, 1, 3)))) # non-square polynomial
zeroes(polm(test_array(dim = c(2, 2, 0)))) # zero polynomial
}

# poles of polynomial matrices #############################################

# polynomials have no poles ###
poles(test_polm(dim = c(2,1), degree = 2, random = TRUE)) 
 
# zeroes of a rational matrix in LMFD form #################################

c = lmfd(test_polm(dim = c(2,2), degree = 3, random = TRUE),
         test_polm(dim = c(2,2), degree = 1, random = TRUE))
(z = zeroes(c))
all.equal(z, zeroes(c$b))

# poles of a rational matrix in LMFD form ##################################

(z = poles(c))
all.equal(z, zeroes(c$a))
}
