% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zz_rldm_simulate_methods.R
\name{sim}
\alias{sim}
\alias{sim.armamod}
\title{Simulate from a State Space or VARMA Model}
\usage{
sim(model, n.obs, rand.gen, n.burnin, ...)

\method{sim}{armamod}(model, n.obs, rand.gen = stats::rnorm, n.burnin = 0, ...)
}
\arguments{
\item{model}{either a \code{\link{armamod}} or \code{\link{stspmod}} object.}

\item{n.obs}{sample size (\eqn{N}).}

\item{rand.gen}{an (optional) function to generate the disturbances \eqn{u_t}{u[t]}. Note that
\code{rand.gen()} should generate an iid sample of a random variable with mean zero
and variance one.}

\item{n.burnin}{length of an initial "burn-in" phase (denoted with \eqn{N_0}{N0}).}

\item{...}{not used.}
}
\value{
List with slots
\item{y}{\eqn{(N,m)} matrix with the generated outputs.}
\item{u}{\eqn{(N,n)} matrix with the noise.}
\item{a}{\eqn{(N+1,s)} matrix with the generated states (\eqn{a_t}{a[t]}, \eqn{t=1,...,N+1}).
         Note that this matrix has (\eqn{N+1}) rows! This slot is only present for state space models.}
}
\description{
Generate a time series from a given process model.
}
\details{
This function was originally part of the R-package \strong{RLDM}.
\cr
In order to generate a "stationary" trajectory (of a stable model) one
has to chose suitable initial starting values.
This is not quite easy, in particular for VARMA models.
As a simple remedy, the procedure offers the option of a "burn-in" phase.
The length of this phase has to be chosen by the user.

If the user would like to have more control on the disturbances
and the initial values, then \code{\link{solve_de}} may be used.
}
\examples{
# Random Walk ############################################################################
model = armamod(lmfd(a = c(1,-1), b = 1))
# generate outputs "y"
n.obs = 100
data = sim(model, n.obs = n.obs, y0 = 1)
plot(data$y, type = 'l')

# bivariate ARMA(2,1) model ##############################################################
model = test_armamod(dim = c(2,2), degrees = c(2,1), bpoles = 1, bzeroes = 1)
# generate outputs "y" with zero initial conditions
n.obs = 50
data =  sim(model, n.obs = n.obs)
# reconstruct noise "u" from given outputs "y"
data1 = solve_inverse_de(model$sys, y = data$y)
all.equal(data$u, data1$u)

}
